---
layout: post
title: Bitwise operators when you can't bit (Fronttick Part 2)
title-lower: bitwise operators when you can't bit (fronttick part 2)
title-tiny: Fronttick (Pt. 2)
blurb: Bitwise operators, ~200 minecraft commands at a time.
usemathjax: true
---
{::nomarkdown}

[block]
I like code that makes you go "wtf?". Code that, no matter how many times you re-read it, just doesn't make any sense. It's not held together by duct tape, but my magic. Let's get straight into it.

```csharp
// Computes `a^b` for a, b any numbers 0, .., 7.
// (int.PositiveMod is only available in my custom System.Int32
//  implementation and not part of "vanilla" .NET
//  It returns not a signed remainder, but the positive remainder.)
public static int Xor8(int a, int b) {
    int a4 = int.PositiveMod(a, 4);
    int b4 = int.PositiveMod(b, 4);
    int res = int.PositiveMod(177, a4 + b4 + 3);
    if (a4 == b4)
        res = 0;
    if (a4 < a ^ b4 < b)
        res += 4;
    return res;
}
```

This bit of code can be [found](https://github.com/Atrufulgium/FrontTick/blob/1bb06e9b8fd4b221b7b75f3cf704be74cb89d199/Compiler/MCMirror/System/BitHelpers.cs#L31) in my c# to Minecraft compiler, Fronttick[^1][^2]. [Last time](/2024/09/11/fronttick-1) I wrote about this compiler I gave an overview about how to handle control flow in the... *unique* setting mcfunction brings. That post was pretty compiler-focused. This time, however, it'll be more mathematical in nature.

The problem
===========
In mcfunction, your only operators are `int += int`, `int -= int`, `int *= int`, `int /= int`, and `int %= int`. That's *much* less than .NET's `System.Int32` gives you! But what if, for some reason, you *really* wanted to do some bitwise math in Minecraft, not caring about performance? Well, you need to implement it yourself.

In this post, I'll discuss how to implement `int ^ int`, `int & int`, and `int | int`. I'll focus in particular on the XOR, as the AND goes very similar, and the OR can be derived from the AND with some NOTs.

As this is part of "reimplementing the System namespace", we also need to be careful with what tools we allow. It's really easy to create a circular dependency that recurses itself to death[^3]. As such, the only things I allow are the following:
- Minecraft's five operators `+`, `-`, `*`, `/`, `%`;
- Boolean arithmetic;
- Control flow.

In particular, boolean arithmetic is implemented completely independently from ints, so we do not get a cyclic dependency if we use `bool ^ bool` in our implementation for `int ^ int`[^4].

A tiny diversion
=================

I did omit a tiny detail in the previous section. Minecraft's `/=` and `%=` are special. In ordinary programming languages, these round towards zero, and maintain the sign, respectively. However, ever since [versions 18w31a and 18w32a](https://bugs.mojang.com/browse/MC-135431), Minecraft deviates from this by internally using Java's `floorDiv` and `floorMod` respectively, which result in rounding down, and giving a positive result[^5] respectively, instead.

This gives my `Int32` class two versions of the two operators. One which conforms to c#'s expectations, and one that uses mcfunction's directly. Naturally, the mcfunction version is more performant.

```csharp
namespace System {
    public struct Int32 {

        ...

        public static int PositiveMod(int a, int b) {
            int res = a;
            Run($"scoreboard players operation {VarName(res)} _ %= {VarName(b)} _");
            return res;
        }

        public static int operator %(int a, int b) {
            int res = PositiveMod(a,b);
            // Flip to the other remainder if signs are wrong
            if (a < 0 & res != 0)
                res -= b;
            if (b < 0 & res != 0)
                res += b;
            return res;
        }

        ...
    }
}
```

Here, the `Run()` method is a compiler intrinsic that turns a string into a raw command, and the `VarName()` method is a compiler intrinsic that converts a c# variable to the name it has in mcfunction.

I must say, it was fun debugging these bitwise operators when I wasn't aware this was an issue!

The lazy solution
=================
Now, let's get to the meat of this post. First, note that instead of implementing XOR full ints at a time, we can also just handle smaller blocks. We can then loop over those smaller blocks until we have handled the full int.

Doing blocks of one bit at a time is the easiest, but also very costly.

```csharp
public static int operator ^(int a, int b) {
    int res = 0;
    int power = 1;
    for (int i = 0; i < 31; i++) {
        // 1 bit xor at a time: just add the two.
        // If both are true, we should be 0 instead.
        int temp = int.PositiveMod(a, 2)
                 + int.PositiveMod(b, 2);
        if (temp == 2) temp = 0;
        // Put this into the result.
        res += temp * power;
        power *= 2;
        a /= 2;
        b /= 2;
    }
    // I'm disregarding the sign bit here, but that's just
    // a headache and doesn't contribute much to the post.
    return res;
}
```

Each iteration of the loop has overhead. While calculating the XOR of one bit takes only 4 commands in mcfunction, there's also all the scaffolding around it. If we unroll the loop into goto form[^6], we see what truly takes up our time.

```csharp
int i = 0;
loop_label:
    // <XOR calculation omitted>
    // Consolidate temp result into result so far
    res += temp * power;                            // 2 commands
    power *= 2;                                     // 1 command
    a /= 2;                                         // 1 command
    b /= 2;                                         // 1 command
    // Explicit for-loop handling          
    i++;                                            // 1 command
    int cond = i < 31;                              // 1 command
    if (cond) goto break_label;                     // 1 command
    else goto loop_label;                           // 1 command
break_label:
```

Each loop iteration adds *nine* commands of overhead, no matter what our XOR calculation looks like! If we can even just go from one bit at a time to two bits at a time, we would *half* the overhead. Let alone even larger amount of bits.

Chinese remainders
==================
Well, if one bit at a time doesn't cut it, what about two? As any sane programmer would do, I looked around the internet whether someone else has had similarly insane problems. And in fact, yes! [This](https://stackoverflow.com/a/48271395) stackoverflow answer had a very interesting, very under-elaborated answer for AND.

```csharp
// Computes `a&b` for a, b any numbers 0, .., 3.
public static int And4(int a, int b) {
    // NOTE: 9 instead of 121 also works.
    return ((121 * a) % 16) % (b+1);
}
```

I was *intrigued*. With just four arithmetic ops, you're able to calculate something that would otherwise require a look-up table with 16 entries. But secretly, this is also just a look-up table. Let's dissect what's going on here.

It's quite a common trick to store data in an int, and look values up with bitwise operators. If your problem is neat enough, you may even have the possibility to overlap these look-ups, so that for instance look-up #1 uses bits 1 through 4, look-up #2 uses bits 3 through 7, whatever. While they're the easiest, bitwise operators aren't the only ways you can do look-ups.

Enter the [Chinese remainder theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem). It states that if we have a system of equations[^7]

$$\begin{equation*}
\begin{cases}
      x\ \%\ n_1 = a_1,
    \\\phantom{x\ \%\ n_2\ } \vdots
    \\x\ \%\ n_k = a_n,
\end{cases}
\end{equation*}$$

there's always a solution if the $n_i$ don't share any factors. This can be used as a look-up table! Your keys must be a bit whacky though, as doing $n_1 = 1$, $n_2 = 2$, $n_3 = 3$ already runs into problems with $n_4 = 4$, as now $n_2$ and $n_4$ share a "two" factor. Your keys are also the upper bound for your value, which is also a somewhat unusual restriction.

But let's try this out. Suppose we want to calculate `1^b`, where `b` is either zero or one. It's a bit of a lame example, but it will demonstrate the above. Our two output values are `1^0 = 1` and `1^1 = 0`. This means we want some function $f(b)$ and a number $x$ so that

$$\begin{equation*}
\begin{cases}
      x\ \%\ f(0) = 1,
    \\x\ \%\ f(1) = 0.
\end{cases}
\end{equation*}$$

If we define $f(b) = b + 2$, we have $n_1 = 2$ and $n_2 = 3$, which are coprime. This allows us to use the Chinese remainder theorem. This gives us an $x$ that solves the above. In this case, $x=3$ (or $9$, or $15$, or ...) works. Thus, `3 % (b+2)` implements `1^b` in ordinary arithmetic.

But this is not a very large look-up table. Doing two arithmetic to get two values? That's lame. Suppose we now want to calculate `2^b`, where `b` may be any number between zero and three. That's a more interesting example! Our four output values are `2^0 = 2`, `2^1 = 3`, `2^2 = 0`, and `2^3 = 1`. This means we want some function $f(b)$ and a number $x$ so that

$$\begin{equation*}
\begin{cases}
      x\ \%\ f(0) = 2,
    \\x\ \%\ f(1) = 3,
    \\x\ \%\ f(2) = 0,
    \\x\ \%\ f(3) = 1.
\end{cases}
\end{equation*}$$

Now, creating a function $f(b)$ whose values are mutually coprime is a bit of a hassle. Especially if you want to do it in very few operations! The Chinese remainder theorem gives us a solution in case everything is coprime. But this doesn't mean that all hope is lost if we allow some values to share factors, we just need to do some work ourselves.

Take for instance the following two systems.

$$\begin{equation*}
\begin{cases}
      x\ \%\ 2 = 1,
    \\x\ \%\ 4 = 3;
\end{cases}
\qquad
\begin{cases}
      y\ \%\ 2 = 1,
    \\y\ \%\ 4 = 2.
\end{cases}
\end{equation*}$$

Even if $2$ and $4$ share factors, the systems may sometimes still be solved. The "$x\ \%\ 2 = 1$" requirement scales up to "$x\ \%\ 4 = 1$ or $x\ \%\ 4 = 3$". This is compatible with the second requirement, and the system can be simplified to "$x\ \%\ 4 = 3$", just one equation, which has solutions. However, the other system is not so lucky. The requirements "$y\ \%\ 4 = 1$ or $y\ \%\ 4 = 3$" and "$y\ \%\ 4 = 2$" are actually incompatible. There is no $y$ that satisfies the system.

Returning to our example of calculating `2^b`, the $f(b)$ don't need to be fully coprime if the values we assign are compatible *enough*. Some clever trial and error[^8] gives us the following:

$$\begin{equation*}
\begin{cases}
      78\ \%\ 4 = 2,
    \\78\ \%\ 5 = 3,
    \\78\ \%\ 6 = 0,
    \\78\ \%\ 7 = 1.
\end{cases}
\end{equation*}$$

Here, $4$ and $6$ share a factor, but that doesn't matter, because their outputs are "compatible enough". In other words, we get `78 % (b+3) = 2^b`. We just got four values with only two operations! That's pretty good.

But we're not really interested in just calculating `2^b`. No, what we really want is `a^b`. We can repeat the above process, and (miraculously!) we get `416 % (b+3) = 0^b`, `345 % (b+3) = 1^b`, and `7 % (b+3) = 3^b`. In general, there is no reason for the same modulus (`b+3`) to work for all of them, but it did.

If we can now create a simple function $g(a)$ that spits out $(416,345,78,7)$, we have implemented `a^b` as `g(a) % (b+3)`. As we're working with modular arithmetic, we can also add $420$ to all of these freely, as $420\ \%\ (b+3) = 0$ for all values of $b$.

I will choose values $(-4, 345, 78, 427)$. The differences between these entries are, in order, $349$, $-267$, and $349$. If we now choose to work modulo $616$, we have $349\ \%\ 616 = -267\ \%\ 616$, so that these are spaced apart by the "same amount"![^9]

With this, we can efficiently generate these four values by calculating `(349*a % 616) - 4`. This is our $g(a)$. Putting everything together, we obtain the following code.

```csharp
// Computes `a^b` for a, b any numbers 0, .., 3.
public static int Xor4(int a, int b) {
    return (((349 * a) % 16) - 4) % (b+3);
}
```
With five arithmetic operators, we implemented what *would* be a look-up table with 16 entries. This XOR is unfortunately one more operator than the AND, which can't really be avoided with this setup.

> **Exercise**: I worked through the XOR operator in the text above. Try to explain the constants in the AND operator implementation at the top of this section, which appear for similar reasons:
> ```csharp
> // Computes `a&b` for a, b any numbers 0, .., 3.
> public static int And4(int a, int b) {
>     return ((9 * a) % 16) % (b+1);
> }
> ```
> Why does the XOR implementation have an additional `-4` that does not have an equivalent in the AND implementation?
> 
> **Exercise**: Implement the following OR operator with at most five arithmetic operators:
> ```csharp
> // Computes `a|b` for a, b any numbers 0, .., 3.
> public static int Or4(int a, int b) {
>     return ...;
> }
> ```
> 
> *Or don't, I actually hope you won't need this stuff! It's a little too cursed.*

Why not just use look-up tables?
================================

[/block]

[^1]: I still don't know whether I write it as "fronttick", "Fronttick", or "FrontTick". I guess the name will never be consistent.
[^2]: Two-thirds of the linked code is explanation already...
[^3]: Not that I allow non-tail recursion, but that's besides the point.
[^4]:
    For reference, `bool ^ bool` is implemented with [this lovely mixture](https://github.com/Atrufulgium/FrontTick/blob/1bb06e9b8fd4b221b7b75f3cf704be74cb89d199/Compiler/MCMirror/System/Bool.cs#L35) of c# and mcfunction:

    ```csharp
    // Note: in mcfunction, we interpret 0 = false, 1 = true, and other values = invalid.
    public static bool operator ^(bool a, bool b) {
        // res = a + b
        // if (res == 2) res = 0
        bool res;
        res = a;
        Run($"scoreboard players operation {VarName(res)} _ += {VarName(b)} _");
        Run($"execute if score {VarName(res)} _ matches 2 run scoreboard players set {VarName(res)} _ 0");
        return res;
    }
    ```
    
    The basic integer operations also come down to code that looks like this -- I have to start *somewhere*. This also has the funny side-effect that `bool` and `int` don't hold any data as far as c# is concerned, even though their functionalities are completely defined in c#. This is completely opposite to [the CLR implementation](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Int32.cs) where ints *do* have a internal value, but no operators are implemented. (There's not even any `extern` operators! Cheaters.)

[^5]: It actually maintains the sign of the second argument, but *what mad-lad would take the remainder with respect to a negative value*? For all intents and purposes, the result will be positive.
[^6]: See the [previous post](/2024/09/11/fronttick-1) for more details than you could ever ask for.
[^7]: I'm writing the remainder operator instead of working with modulo classes so that programmers stumbling upon this don't get completely blindsided. I will also assume that this remainder operator returns the positive remainder.
[^8]: Did I say clever trial and error? I'm just brute-forcing it lol. TODO: LINK
[^9]: With this approach, you must alternate adding and subtracting; doing $+x$ and $+y$ can't really be justified as "actually the same modulus" the same way as doing $+x$ and $-y$.

{:/nomarkdown}