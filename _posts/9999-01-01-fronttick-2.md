---
layout: post
title: Bitwise operators when you can't bit (Fronttick Part 2)
title-lower: bitwise operators when you can't bit (fronttick part 2)
title-tiny: Fronttick (Pt. 2)
blurb: Bitwise operators, ~200 minecraft commands at a time.
---
{::nomarkdown}

[block]
I like code that makes you go "wtf?". Code that, no matter how many times you re-read it, just doesn't make any sense. It's not held together by duct tape, but my magic. Let's get straight into it.

```csharp
// Computes `a^b` for a, b any numbers 0, .., 7.
// (int.PositiveMod is only available in my custom System.Int32
//  implementation and not part of "vanilla" .NET
//  It returns not a signed remainder, but the positive remainder.)
public static int Xor8(int a, int b) {
    int a4 = int.PositiveMod(a, 4);
    int b4 = int.PositiveMod(b, 4);
    int res = int.PositiveMod(177, a4 + b4 + 3);
    if (a4 == b4)
        res = 0;
    if (a4 < a ^ b4 < b)
        res += 4;
    return res;
}
```

This bit of code can be [found](https://github.com/Atrufulgium/FrontTick/blob/1bb06e9b8fd4b221b7b75f3cf704be74cb89d199/Compiler/MCMirror/System/BitHelpers.cs#L31) in my c# to Minecraft compiler, Fronttick[^1][^2]. [Last time](/2024/09/11/fronttick-1) I wrote about this compiler I gave an overview about how to handle control flow in the... *unique* setting mcfunction brings. That post was pretty compiler-focused. This time, however, it'll be more mathematical in nature.

The problem
===========
In mcfunction, your only operators are `int += int`, `int -= int`, `int *= int`, `int /= int`, and `int %= int`. That's *much* less than .NET's `System.Int32` gives you! But what if, for some reason, you *really* wanted to do some bitwise math in Minecraft, not caring about performance? Well, you need to implement it yourself.

In this post, I'll discuss how to implement `int ^ int`, `int & int`, and `int | int`. I'll focus in particular on the XOR, as the AND goes very similar, and the OR can be derived from the AND with some NOTs.

As this is part of "reimplementing the System namespace", we also need to be careful with what tools we allow. It's really easy to create a circular dependency that recurses itself to death[^3]. As such, the only things I allow are the following:
- Minecraft's five operators `+`, `-`, `*`, `/`, `%`;
- Boolean arithmetic;
- Control flow.

In particular, boolean arithmetic is implemented completely independently from ints, so we do not get a cyclic dependency if we use `bool ^ bool` in our implementation for `int ^ int`[^4].

A tiny diversion
=================

I did omit a tiny detail in the previous section. Minecraft's `/=` and `%=` are special. In ordinary programming languages, these round towards zero, and maintain the sign, respectively. However, ever since [versions 18w31a and 18w32a](https://bugs.mojang.com/browse/MC-135431), Minecraft deviates from this by internally using Java's `floorDiv` and `floorMod` respectively, which result in rounding down, and giving a positive result[^5] respectively, instead.

This gives my `Int32` class two versions of the two operators. One which conforms to c#'s expectations, and one that uses mcfunction's directly. Naturally, the mcfunction version is more performant.

```csharp
namespace System {
    public struct Int32 {

        ...

        public static int PositiveMod(int a, int b) {
            int res = a;
            Run($"scoreboard players operation {VarName(res)} _ %= {VarName(b)} _");
            return res;
        }

        public static int operator %(int a, int b) {
            int res = PositiveMod(a,b);
            // Flip to the other remainder if signs are wrong
            if (a < 0 & res != 0)
                res -= b;
            if (b < 0 & res != 0)
                res += b;
            return res;
        }

        ...
    }
}
```

Here, the `Run()` method is a compiler intrinsic that turns a string into a raw command, and the `VarName()` method is a compiler intrinsic that converts a c# variable to the name it has in mcfunction.

I must say, it was fun debugging these bitwise operators when I wasn't aware this was an issue!

The lazy solution
=================
Now, let's get to the meat of this post. First, note that instead of implementing XOR full ints at a time, we can also just handle smaller blocks. We can then loop over those smaller blocks until we have handled the full int.

Doing blocks of one bit at a time is the easiest, but also very costly.

```csharp
public static int operator ^(int a, int b) {
    int res = 0;
    int power = 1;
    for (int i = 0; i < 31; i++) {
        // 1 bit xor at a time: just add the two.
        // If both are true, we should be 0 instead.
        int temp = int.PositiveMod(a, 2)
                 + int.PositiveMod(b, 2);
        if (temp == 2) temp = 0;
        // Put this into the result.
        res += temp * power;
        power *= 2;
        a /= 2;
        b /= 2;
    }
    // I'm disregarding the sign bit here, but that's just
    // a headache and doesn't contribute much to the post.
    return res;
}
```

Each iteration of the loop has overhead. While calculating the XOR of one bit takes only 4 commands in mcfunction, there's also all the scaffolding around it. If we unroll the loop into goto form[^6], we see what truly takes up our time.

```csharp
int i = 0;
loop_label:
    // <XOR calculation omitted>
    // Consolidate temp result into result so far
    res += temp * power;                            // 2 commands
    power *= 2;                                     // 1 command
    a /= 2;                                         // 1 command
    b /= 2;                                         // 1 command
    // Explicit for-loop handling          
    i++;                                            // 1 command
    int cond = i < 31;                              // 1 command
    if (cond) goto break_label;                     // 1 command
    else goto loop_label;                           // 1 command
break_label:
```

Each loop iteration adds *nine* commands of overhead, no matter what our XOR calculation looks like! If we can even just go from one bit at a time to two bits at a time, we would *half* the overhead. Let alone even larger amount of bits.

Two bits at a time
==================
Well, if one bit at a time doesn't cut it, what about two? As any sane programmer would do, I looked around the internet whether someone else has had similarly insane problems. And in fact, yes! [This](https://stackoverflow.com/a/48271395) stackoverflow answer had a very interesting, very under-elaborated answer for AND.

```csharp
// Computes `a&b` for a, b any numbers 0, .., 3.
public static int And4(int a, int b) {
    return (((121 * a) % 16) % (b+1));
}
```

I was *intrigued*. With just four arithmetic ops, you're able to calculate something that would otherwise require a look-up table with 16 entries. But secretly, this is also just a look-up table. Let's dissect what's going on here.

[/block]

[^1]: I still don't know whether I write it as "fronttick", "Fronttick", or "FrontTick". I guess the name will never be consistent.
[^2]: Two-thirds of the linked code is explanation already...
[^3]: Not that I allow non-tail recursion, but that's besides the point.
[^4]:
    For reference, `bool ^ bool` is implemented with [this lovely mixture](https://github.com/Atrufulgium/FrontTick/blob/1bb06e9b8fd4b221b7b75f3cf704be74cb89d199/Compiler/MCMirror/System/Bool.cs#L35) of c# and mcfunction:

    ```csharp
    // Note: in mcfunction, we interpret 0 = false, 1 = true, and other values = invalid.
    public static bool operator ^(bool a, bool b) {
        // res = a + b
        // if (res == 2) res = 0
        bool res;
        res = a;
        Run($"scoreboard players operation {VarName(res)} _ += {VarName(b)} _");
        Run($"execute if score {VarName(res)} _ matches 2 run scoreboard players set {VarName(res)} _ 0");
        return res;
    }
    ```

    Here, the `Run()` method is a compiler intrinsic that turns a string into raw mcfunction, and the `VarName()` method is a compiler intrinsic that converts a c# variable to the name it has in mcfunction.

    The basic integer operations also come down to code that looks like this -- I have to start *somewhere*. This also has the funny side-effect that `bool` and `int` don't hold any data as far as c# is concerned, even though their functionalities are completely defined in c#. This is completely opposite to [the CLR implementation](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Int32.cs) where ints *do* have a internal value, but no operators are implemented. (There's not even any `extern` operators! Cheaters.)

[^5]: It actually maintains the sign of the second argument, but *what mad-lad would take the remainder with respect to a negative value*? For all intents and purposes, the result will be positive.
[^6]: See the [previous post](/2024/09/11/fronttick-1) for more details than you could ever ask for.

{:/nomarkdown}