---
layout: post
title: What idiot would want to compile C# into MCFunction? (Fronttick Part 1)
title-lower: what idiot would want to compile c# into mcfunction? (fronttick part 1)
title-tiny: Fronttick (Pt. 1)
blurb: When even compiling just a `for`-loop into MCFunction is _hard_.
usemathjax: true
---
{::nomarkdown}

[block]
You have regular programming languages, like c#, java, python, and the like. Then there are the esoteric languages, such as brainfuck, piet, or malbolge.

And then there is [mcfunction](https://minecraft.wiki/w/Function_(Java_Edition)), Minecraft's programming language. Somehow, this language isn't really either of the two kinds. Starting out as just simple commands to modify the world, it's grown into an incredibly weird programming language, that you can't just call a "regular programming language". On the other hand, the weirdness I'm about to discuss it not intentional, so I'd hardly call it an "esoteric language" either.

Nevertheless, I'm an idiot, and I'm working[^1] on a compiler "Fronttick" to translate from c# to mcfunction. I have to deal with these idiosyncrasies, and I have no one to blame but myself.

In this post, I'll discuss some very basic issues you'll encounter when trying to do something as simple as "control flow".

Gradually increasing weirdness
==============================
As noted before, mcfunction did not start out as a fully fledged programming language. You could only put *command blocks* into the in-game world, and had to use in-game blocks for program flow. Commands were used more for things like telling the player a story, spawning mobs, etc.

<!-- Note, as of 2024/09/09, Rouge (forced by github pages) does not support
     mcfunction. As a hack, use another language I won't ever use, instead.
     Somewhat decent options: Elixir / Praat / Ruby. -->
```mcfunction
say hi imma scare ya!
spawn creeper 0 60 0
setblock 0 59 0 tnt
```

Somewhat importantly, there is also a simple *scoreboard* you could use to store values.

```mcfunction
scoreboard players set Atru my_score 3
scoreboard players operation Atru my_score *= Atru another_score
```
In c# terms, a `Dictionary<(string entity, string objective), int>` would not be an inaccurate description for the scoreboard. Notably, the `entity` can be any mob in the world, but it does not necessarily need to exist. It can also just be any string, or mobs that have been killed already, which gives quite some wriggle room.

The scoreboard was intended to be used to, well, store scores players could obtain in simple minigames. This means that that integers are all you get. Additionally, your only arithmetic options are `+=`, `-=`, `*=`, `/=`, and `%=`[^2]. That's it.

Another interesting feature of mcfunction are *selectors*. These can be used to select one or multiple entities. If a selector selects multiple entities, the command affects all of them[^3]. The most common selectors are `@a` (`a`ll players), `@e` (all `e`ntities), and `@s` (your`s`elf).
```mcfunction
scoreboard players set @a my_score 3
tp @e Atru
```

So far, so good. We have some non-standard choices, but nothing too out there yet. After all, it's not yet intended to be a fully fledged programming language, but just to allow people to add some interactivity to their worlds.

In order to not have to spend too much time building physical control flow, an `execute` command was introduced. Among other things[^4], you can test for scores, and only do stuff if the test succeeds[^5].
```mcfunction
execute if score Atru my_score matches 10.. say lots of points!
execute unless score Atru my_score matches 10.. say few points...
```

At some point, the devs realised that it's a bit inconvenient to have to build all your commands in the game world. They introduced *data packs* which have *function* files.
```mcfunction
# File datapack:square
scoreboard players operation @s my_score *= @s my_score
```
We now have an easy way to square a player's score, by just making them run `function datapack:square`.

Naturally, functions can also call other functions. This gets us to one of the most annoying parts of mcfunction. To do control flow, for instance a simple if/else statement, *you (generally) have to put the if- and else-blocks in separate files*. If your conditionals are simply one command, you can get away with `execute if ... run ...`, but otherwise, you have to run `execute if ... run function ...` to run those multiple commands dependent on the single condition.

Now we also run into another problem. There is no concept of a "call stack" in mcfunction, and returning/jumping out of a nested loop must be done manually. Consider the following pseudocode.
```mcfunction
# File datapack:a
function ...
function ...
execute if ... run function datapack:b
    # File datapack:b
    function ...
    function ...
    execute if ... run function datapack:c
        # File datapack:c
        function ...
        function ...
        # Suppose we want to "return" here.
    function ...
    function ...
function ...
function ...
```
As discussed, mcfunction files' branching requires multiple files. To keep things readable, I write the multiple files as nested code blocks instead. However, I also write the multiple files like this for another reason. This code, in a sane language, this would look something like this:

```csharp
...
...
if (...) {
    ...
    ...
    if (...) {
        ...
        ...
        return;
    }
    ...
    ...
}
...
...
```
This intuitively tells us something: if we reach the inner statement, and we don't have a `return` command handy, all code afterwards gets executed too.

And, unfortunately for us, mcfunction does not have a `return` command handy[^6]. So unless we do something, the code afterwards does get executed. We'll need to deal with this.

Roslyn
======
So far, I've just been blabbering about mcfunction, but this is a post about a compiler, so I also need to talk about a second language. As I wrote earlier, Fronttick is a compiler from c# to mcfunction, so I ought to spend some time talking about c#.

My compiler can be described deceptively simply: take some c# code, and keep rewriting it until it practically looks like mcfunction already. Once we've done this, we can just linearly go through all code and output all mcfunction files.

A simple example of this process is the following. Suppose we have the following c# code.
```csharp
static int limit;
[MCFunction]
static void PrintTriangularNumbers() {
    int triangle = 0;
    for (int i = 1; i < limit; i++) {
        triangle += i;
        Console.WriteLine(i);
    }
}
```
Equivalent (but highly non-idiomatic) code would be the following.
```csharp
static int limit;
static int i;
static int triangle;
static int cond;
[MCFunction]
static void PrintTriangularNumbers() {
    triangle = 0;
    i = 1;
    For();
}
[MCFunction]
static void For() {
    triangle += i;
    Console.WriteLine(i);
    i += 1;
    cond = i;
    cond -= limit;
    if (cond < 0) For();
}
```
This code can be converted into mcfunction very literally.
```mcfunction
# File datapack:print-triangular-numbers
scoreboard players set Var_triangle _ 0
scoreboard players set Var_i _ 1
function datapack:for
    # File datapack:for
    scoreboard players operation Var_triangle _ += Var_i _
    tellraw @a {"score":{"name":"Var_triangle","objective":"_"}}
    scoreboard players add Var_triangle 1
    scoreboard players set Var_cond _ Var_i _
    scoreboard players operation Var_cond _ -= Var_limit _
    execute if score Var_cond matches ..-1 run function datapack:for
```
So how do we rewrite the first c# block that doesn't look like mcfunction, to the second c# block that does? Well, we use Roslyn.

[Roslyn](https://github.com/dotnet/roslyn) is an absolutely wonderful piece of open source that gives us access to everything you need to compile c# code. Not too surprising, since it's *the c# compiler*. However, unlike everyone else, we don't target CIL like everyone else, we target mcfunction[^7], so I won't be using half of its features.

Instead, I'm just using Roslyn's [rewriters](https://learn.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.csharpsyntaxrewriter) (and [walkers](https://learn.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.csharpsyntaxwalker), sometimes) to put the code into the form I want. These visit every node in your syntax tree, and you can replace nodes with other nodes.

As a simple example of this rewriting, suppose we want to simplify any `if (true)` and `if (false)` conditionals. If you visit an if-statement, you check whether the condition is such a literal, and if so, replace the node with its appropriate child block.

```csharp
public override SyntaxNode VisitIfStatement(IfStatementSyntax node) {
    if (node.Condition is LiteralExpressionSyntax lit) {
        if (lit.Kind() == SyntaxKind.TrueLiteralExpression) {
            // When "if (true)", replace the if-statement with just
            // its true-block. This is "node.Statement".
            // Inside such a block might also be something we need to
            // update, so we need to "visit" that too.
            return VisitBlock((BlockSyntax) node.Statement);
        } else if (lit.Kind() == SyntaxKind.FalseLiteralExpression) {
            // When "if (false)", replace the if-statement with just
            // its false-block, if it exists.
            if (node.Else != null) {
                return VisitBlock((BlockSyntax) node.Else.Statement);
            } else {
                return null;
            }
        }
    }
    // There was nothing to update.
    // But we might need to update something deeper down the tree. To
    // access that, we need this call.
    return base.VisitIfStatement(node);
}
```
This is [literally Fronttick code](https://github.com/Atrufulgium/FrontTick/blob/main/Compiler/Compiler/Visitors/IfTrueFalseRewriter.cs), by the way. My entire compiler is like this: we have visitors to gradually make very single-minded changes, and with enough of those, we reach the format we need to simply "read off" the mcfunction from the c#.

[/block]

[^1]: The present participle is a bit of a bold move, given the last commit was in January... I'm busy, okay!
[^2]: I won't note it in this post, but unlike every other programming language, division does not round towards zero, but down towards $-\infty$. Also, the remainder operator does not maintain sign, but always returns the positive modulus.
[^3]: Only if this would make sense, but it's quite intuitive in which contexts multiple selectors are allowed. You can teleport many mobs to one, but you cannot teleport one mob to many.
[^4]: This command is only rivalled by the assembly `mov`-instruction in terms of versatility.
[^5]: I'm using modern syntax, and not the syntax as when `execute` was introduced.
[^6]:
    Okay, as of this year, mcfunction *does* have a `return` command, but you can only use it to escape the current file. If you are in a nested context, you *still* manually need to check whether the context you just left `return`ed for you to continue the chain.

    I'm also disinterested in the `return` command for another reason: the only types you can return with it are `void` and `int`. I want to return arbitrary structs, so I need a custom system anyways.

    (And I just don't want to rewrite my old code. Precisely this control flow is [the most ugly thing](https://github.com/Atrufulgium/FrontTick/blob/1bb06e9b8fd4b221b7b75f3cf704be74cb89d199/Compiler/Compiler/Visitors/GotoFlagifyRewriter.cs) in the entire compiler's codebase.)

[^7]:
    You might be wondering, fundamentally, why Fronttick directly compiles into mcfunction, instead of going to some lower-level language for which there already exist compilers into mcfunction, or implementing the CLR in mcfunction myself. The answer is quite simple; as I mentioned above, regular languages have a call stack. It's fundamental to nearly every programming language in existence, and just a given on hardware.

    But mcfunction *doesn't have a call stack*, or scope, or anything of the sort. All variables are global. If you call a function within a function, you just overwrite its own data. You *can* implement call stacks by being very clever, but that requires either interfacing with the world, or with nbt, neither of which are ideal. I don't want the base framework to mess with the world, and nbt is generally slow.

    But when making datapacks, you don't *really* need a call stack. If we disallow recursion, we can just make every local variable a unique global variable, and then everything runs correctly. Most people won't even need recursion when writing code for minecraft. In this case, the trade-off is clear. Disallow recursion, but don't have the overhead of simulating a call stack.

    In the case recursion is actually needed, the solution is simple. Allow for a `[Recursive(64)]` attribute on methods that states "this method can be called up to 64 levels of recursion". The implementation? Just make 63 copies of the method, with each one calling the next, up until the "stack" "overflows".

{:/nomarkdown}