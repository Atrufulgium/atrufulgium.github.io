---
layout: post
title: >
    Julia plotter: Baby's third compiler
title-lower: >
    julia plotter: baby's third compiler
title-tiny: julia plotter
blurb: Parsing math into GLSL to render Julia sets.
usemathjax: true
---
{::nomarkdown}

[block]
So, on the first iteration of this website, I had this "Julia plotter" thingamajig. The code's very old already and pretty bad, but if I'm going to write about compilers on this blog, I might as well start with something small and easy.

In this post, I'll discuss this plotter, why you shouldn't care, the code behind it, and why you should care. Without further ado, let's first take a look at the plotter:
[/block]

[block]
{% include julia.html %}
[/block]

[block]
In the above visualization, you can write some math[^1], and then the plotter plots its *Julia set*. You can zoom in as you'd expect, and you can focus the image around a different point by clicking there. If your math's doing something weird, you'll even get a very vague error message!

Julia sets
==========
Julia sets are a mathematical curiosity part of chaos theory. Consider the sequence $(z, f(z), f(f(z)), f(f(f(z))), \dots)$, where $f$ is a user-specified function. This thing simply counts how long it takes each starting point before you're "far" from the origin, and colours based on that.

The motivation for this is that you'll see only two behaviours: your starting point either blasts away to wherever, or it doesn't. In certain cases, you can prove that once you're $x$ distance away from the origin, you're going to go infinitely far out. I'm completely ignoring this "certain" keyword, and just letting you use whatever function. As a result, this thing is provably reasonably accurate for all functions $f(z) = z^2 + c$, but all bets are off for anything else. Therefore, the actual mathematical value of this plotter is somewhat limited. Just consider it as a "funky picture generator".

If you want to learn more about Julia sets, the [Wikipedia](https://en.wikipedia.org/wiki/Julia_set) page is pretty understandable, or you could just grab a good ol' textbook[^2].

Compilers
=========
With that out of the way, time to get to the point of this post: how I made this. The idea is simple: just write some shader that does the iteration, and depending on how many iterations it takes, give it a different colour.

```glsl
// For each pixel...
void main() {
    // Prep work: handle the viewport to find the what number
    // this coordinate represents.
    vec2 z = vPosition.xy * exp(zoom) - offset;
    z.x *= aspectRatio;

    // Actually do the iteration.
    // (Stop after some limit, and see that as âˆž.)
    float iters = 0.;
    for (float i = 0.; i < 100.; i++) {
        z = /* f(z) -- put compiled user code here */;
        iters += float(dot(z,z) < 9.);
    }

    // Colour based on the amoutn of iterations.
    // (This `vSampler` contains a linear Viridis scale.
    //  I liked a logarithmic scaling more.)
    float progress = log2(iters + 2.)/log2(102.);
    gl_FragColor = texture2D(vSampler, vec2(progress,0.5));
}
```

What we have to do is "simple". We have to take some math that the user wrote, and turn it into valid shader code. This is exactly what a compiler/interpreter is for.

Generally, compilers/interpreters can be outlined into a few rough steps:
- First, *tokenization*: take the user's text, and turn it into tokens. Instead of working character per character, this allows us to work with significant text blocks. For instance a full `function` may be one token, just like a single mathematical operator `-`. This only exists to make our lives easier.

    This can be combined with the next step if you're adventurous, but I'm not. In this post, we'll properly handle both steps.
- Next, *parsing*: turn this list of tokens into *syntax tree*. A syntax tree is the most natural way to analyse a bunch of code; you can ask operators what their operands are, you can ask function calls what their arguments are, etc.

    IMAGE

    By doing this, you don't have to care about the textual representation of the code, which is a godsent. Imagine having to account for whitespace every time you wanted to loop over a function's arguments!
- Optionally, you can *analyse* en *optimize* the resulting syntax tree. This is usually where the "meat" of a compiler is[^3]. You can do type checking, constant folding, the possibilities are endless.

    For example, while the following two syntax trees mean the same, one is clearly more efficient than the other. Naturally, you'd like to always get the more efficient tree:

    IMAGE

    My optimization consists of "n/a", while my analysis consists of determining whether we're working with real, or with complex numbers, in every step. For instance, the "sign" function only makes sense on real numbers, so if we're asking for $\text{sgn}(i)$, we should tell the user "no can do".
- The next step depends on whether you're a compiler or an interpreter. If you're an interpreter, you walk the syntax tree, executing nodes as you encounter them. If you're a compiler, you take the syntax tree, and turn it back into text, bytcode, or whatever else is appropriate.

    Depending on the complexity of your language(s), this step is either very easy or very hard. In most cases, it's the latter. Luckily, in our case, it's the former.

Let's go through these steps one by one.

Tokenization
============

Parsing
=======

Analysis
========

Output
======

[/block]

[^1]:
    I support way too much math. Apart from the standard arithmetic operations, there's a whole lot more: `re`, `im`, `abs`, `sgn`, `normalize`, `ceil`, `floor`, `round`, `fract`, `clamp`, `max`, `min`, `avg`, `exp`, `ln`, `sqrt`, `cos`, `cosh`, `acos`, `acosh`, and the `sin` and `tan` variants of those. All of these are pretty self-explanatory.

    Of note is that $\log(z)$ is a [multivalued function](https://en.wikipedia.org/wiki/Multivalued_function). Because $e^{w + \alpha\pi} = e^{w + \alpha\pi i + 2k\pi i}$ for any $k \in \mathbb Z$, any complex value has multiple logarithms. I'm using the *principal branch*: the angle component that's giving us multivalued problems will be restricted to $(-\pi,\pi]$ to give us unique values again.

    This multivalued note also holds for the inverse trig functions. These can be [defined in terms of the principal logarithm](https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Logarithmic_forms), and that's exactly what I'm doing, so these pose no problem.

[^2]: The one I'm familiar with is "*An Introduction to Chaotic Dynamical Systems*" by Robert L. Devaney. It be good.
[^3]: Just to give you an idea: my very unfinished compiler from c# to mcfunction has around 37 different passes in this step (which excludes everything Roslyn does for me already!). Another compiler for a bullet hell project of mine has around 17 passes. Of course, proper professional compilers blow these numbers out of the water.

{:/nomarkdown}